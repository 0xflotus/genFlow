type fileInfo = {
  pathNoExt: string,
  basenameNoExt: string,
  jsLines: list(string),
  reLines: array(string),
};

let readLines = (file: string): list(string) => {
  let lines = ref([]);
  let chan = open_in(file);
  let finished_lines =
    try (
      {
        while (true) {
          lines := lines^ @ [input_line(chan)];
        };
        [];
      }
    ) {
    | End_of_file =>
      close_in(chan);
      lines^;
    };
  finished_lines;
};

/**
 * Reads the given file and returns information about the file.
 */
let readFile = (file: string): fileInfo => {
  let pathNoExt = file |> Filename.chop_extension |> Filename.chop_extension;
  let reasonPath = pathNoExt ++ ".re";
  let reLines = readLines(reasonPath);
  let jsPath = pathNoExt ++ ".bs.js";
  let jsLines = readLines(jsPath);
  {
    pathNoExt,
    basenameNoExt: Filename.basename(pathNoExt),
    jsLines,
    reLines: Array.of_list(reLines),
  };
};

let writeFile = (file: string, contents: string) => {
  let outFile = open_out(file);
  output_string(outFile, contents);
  close_out(outFile);
};

let replace = ((regexp, replacement), str) =>
  Str.global_replace(regexp, replacement, str);

let executeReplacements = (replacements, line) =>
  List.fold_left(
    (line, replacement) => replace(replacement, line),
    line,
    replacements,
  );

let reasonAlreadyCheckedType = "SafeReasonValueNotExportedToFlow";
let any = "any";

let rec seenFlowString = (flowStrings, exportName) =>
  switch (flowStrings) {
  | [] => None
  | [(reasonBindingName, flowText), ...tl]
      when reasonBindingName == exportName =>
    Some(flowText)
  | [hd, ...tl] => seenFlowString(tl, exportName)
  };

/**
 * Reason files may export strings containing flow type definitions for their
 * corresponding Reason bindings and those will be turned into Flow type
 * annotations on the generated .bs.js file.
 *
 * This is useful for auto-generated Reason files that have the goal of binding
 * to Flow.
 *
 *     let __flowTypeValueAnnotation__identifier = "number";
 *     let identifier = 0;
 *
 * If any one exported let binding has a flow type definition the file will
 * become @flow enabled, and every binding that does not have a
 * `__flowTypeValueAnnotation` will be given an annotated type of
 * `SafeReasonValueNotExportedToFlow`.
 *
 * If no Reason bindings have corresponding `__flowTypeValueAnnotation`s
 * specified, then the entire file will not have Flow enabled.
 */
open BuckleScriptPostProcessLib;
let identifierToCapitalize =
  Str.regexp(Patterns.capitalizeExportedNamePrefix ++ "\\([A-Za-z_]+\\)");

let exportedName = s =>
  s |> Str.global_replace(identifierToCapitalize, "\\1");

let addHeader = fileInfo => {
  let isGenerated = fileInfo.reLines[0] == Patterns.generatedHeaderPrefix;
  if (isGenerated) {
    let headerStart = [
      "/**",
      " * This is file generated by genFlow. Do not modify.",
      " *",
    ];
    let headerMiddle = [" * @flow strict"];
    let headerEnd = [" * @nolint", " */", ""];
    let jsLines = headerStart @ headerMiddle @ headerEnd @ fileInfo.jsLines;
    {...fileInfo, jsLines};
  } else {
    fileInfo;
  };
};

let capitalizeIdentifiers = fileInfo => {
  let jsLines = fileInfo.jsLines |> List.map(exportedName);
  {...fileInfo, jsLines};
};

let generate = fileInfo => String.concat("\n", fileInfo.jsLines) ++ "\n";

let run = file =>
  file
  |> readFile
  |> addHeader
  |> capitalizeIdentifiers
  |> generate
  |> writeFile(file);

switch (Sys.argv) {
| [||]
| [|_|]
| [|_, "" | "help" | "-help" | "--help"|] =>
  print_endline(
    {|
This script takes JavaScript file path as a single argument. Calling it might look like:

/path/to/BuckleScriptPostProcess.exe /path/to/outputFile.bs.js

It is specifically designed to be called by BuckleScript. You should never need to call it by hand.
|},
  )
| args => run(args[1])
};