type fileInfo = {
  pathNoExt: string,
  basenameNoExt: string,
  jsLines: list(string),
  reLines: array(string),
};

let readLines = (file: string): list(string) => {
  let lines = ref([]);
  let chan = open_in(file);
  let finished_lines =
    try (
      {
        while (true) {
          lines := lines^ @ [input_line(chan)];
        };
        [];
      }
    ) {
    | End_of_file =>
      close_in(chan);
      lines^;
    };
  finished_lines;
};

/**
 * Reads the given file and returns information about the file.
 */
let readFile = (file: string): fileInfo => {
  let pathNoExt = file |> Filename.chop_extension |> Filename.chop_extension;
  let reasonPath = pathNoExt ++ ".re";
  let reLines = readLines(reasonPath);
  let jsPath = pathNoExt ++ ".bs.js";
  let jsLines = readLines(jsPath);
  {
    pathNoExt,
    basenameNoExt: Filename.basename(pathNoExt),
    jsLines,
    reLines: Array.of_list(reLines),
  };
};

let writeFile = (file: string, contents: string) => {
  let outFile = open_out(file);
  output_string(outFile, contents);
  close_out(outFile);
};

let replace = ((regexp, replacement), str) =>
  Str.global_replace(regexp, replacement, str);

let executeReplacements = (replacements, line) =>
  List.fold_left(
    (line, replacement) => replace(replacement, line),
    line,
    replacements,
  );

let rec seenFlowString = (flowStrings, exportName) =>
  switch (flowStrings) {
  | [] => None
  | [(reasonBindingName, flowText), ...tl]
      when reasonBindingName == exportName =>
    Some(flowText)
  | [hd, ...tl] => seenFlowString(tl, exportName)
  };

open BuckleScriptPostProcessLib;
let identifierToCapitalize =
  Str.regexp(Patterns.capitalizeExportedNamePrefix ++ "\\([A-Za-z_]+\\)");

let exportedName = s =>
  s |> Str.global_replace(identifierToCapitalize, "\\1");

let addHeader = fileInfo => {
  let isGenerated = fileInfo.reLines[0] == Patterns.generatedHeaderPrefix;
  if (isGenerated) {
    let headerStart = [
      "/**",
      " * This is file generated by genFlow. Do not modify.",
      " *",
    ];
    let headerMiddle = [" * @flow strict"];
    let headerEnd = [" * @nolint", " */", ""];
    let jsLines = headerStart @ headerMiddle @ headerEnd @ fileInfo.jsLines;
    {...fileInfo, jsLines};
  } else {
    fileInfo;
  };
};

let capitalizeIdentifiers = fileInfo => {
  let jsLines = fileInfo.jsLines |> List.map(exportedName);
  {...fileInfo, jsLines};
};

module StringMap = Map.Make(String);

let annotateFlowExports = fileInfo => {
  let foldLine = ((map, lines), nextLine) =>
    if (Str.string_match(Patterns.flowStringVar, nextLine, 0)) {
      let key = nextLine |> Str.matched_group(1);
      let value = nextLine |> Str.matched_group(2);
      (map |> StringMap.add(key, value), lines);
    } else if (Str.string_match(Patterns.exportedIdentWithPrefix, nextLine, 0)) {
      (
        /* ignore -- not sure why this case is generated */
        map,
        lines,
      );
    } else if (Str.string_match(Patterns.exportedIdent, nextLine, 0)) {
      let lhs = nextLine |> Str.matched_group(1);
      let rhs = nextLine |> Str.matched_group(2);
      if (map |> StringMap.mem(rhs)) {
        let nextLineNew =
          "exports."
          ++ lhs
          ++ " = ("
          ++ rhs
          ++ " : "
          ++ (map |> StringMap.find(rhs))
          ++ ");";
        (map, [nextLineNew, ...lines]);
      } else {
        (map, [nextLine, ...lines]);
      };
    } else {
      (map, [nextLine, ...lines]);
    };
  let (_, revJSLines) =
    List.fold_left(foldLine, (StringMap.empty, []), fileInfo.jsLines);
  {...fileInfo, jsLines: List.rev(revJSLines)};
};

let generate = fileInfo => String.concat("\n", fileInfo.jsLines) ++ "\n";

let run = file =>
  file
  |> readFile
  |> addHeader
  |> capitalizeIdentifiers
  |> annotateFlowExports
  |> generate
  |> writeFile(file);

switch (Sys.argv) {
| [||]
| [|_|]
| [|_, "" | "help" | "-help" | "--help"|] =>
  print_endline(
    {|
This script takes JavaScript file path as a single argument. Calling it might look like:

/path/to/BuckleScriptPostProcess.exe /path/to/outputFile.bs.js

It is specifically designed to be called by BuckleScript. You should never need to call it by hand.
|},
  )
| args => run(args[1])
};