open GenFlowCommon;

let genericsString = genericStrings =>
  genericStrings === [] ?
    "" : "<" ++ String.concat(",", genericStrings) ++ ">";

let rec renderString = (~language, ~exact, typ) =>
  switch (typ) {
  | Optional(typ) => "?" ++ (typ |> renderString(~language, ~exact))
  | Ident(identPath, typeArguments) =>
    identPath
    ++ genericsString(
         List.map(renderString(~language, ~exact), typeArguments),
       )
  | ObjectType(fields) => fields |> renderObjType(~language, ~exact)
  | Arrow(typeParams, valParams, retType) =>
    renderFunType(~language, ~exact, typeParams, valParams, retType)
  }
and renderField = (~language, ~exact, (lbl, optness, typ)) => {
  let optMarker = optness === NonMandatory ? "?" : "";
  lbl ++ optMarker ++ ":" ++ (typ |> renderString(~language, ~exact));
}
and renderObjType = (~language, ~exact, fields) =>
  (exact ? "{|" : "{")
  ++ String.concat(
       exact ? ", " : "; ",
       List.map(renderField(~language, ~exact), fields),
     )
  ++ (exact ? "|}" : "}")
/* TODO: Always drop the final unit argument. */
and renderFunType = (~language, ~exact, typeParams, valParams, retType) =>
  genericsString(List.map(renderString(~language, ~exact), typeParams))
  ++ "("
  ++ String.concat(
       ", ",
       List.mapi(
         (i, t) => {
           let parameterName =
             language == Flow ? "" : "_" ++ string_of_int(i + 1) ++ ":";
           parameterName ++ (t |> renderString(~language, ~exact));
         },
         valParams,
       ),
     )
  ++ ") => "
  ++ (retType |> renderString(~language, ~exact));

let typToString = (~language) =>
  renderString(~language, ~exact=language == Flow);

let ofType = (~language, ~typ, s) =>
  language == Untyped ? s : s ++ ": " ++ (typ |> typToString(~language));

let commentBeforeRequire = (~language) =>
  language == Typescript ?
    "// tslint:disable-next-line:no-var-requires\n" : "";

let emitExportType =
    (~language, ~opaque, ~typeName, ~typeParams, ~comment, typ) => {
  let typeParamsString =
    genericsString(List.map(typToString(~language), typeParams));
  let commentString =
    switch (comment) {
    | None => ""
    | Some(s) => " /* " ++ s ++ " */"
    };

  switch (language) {
  | Flow =>
    "export"
    ++ (opaque ? " opaque " : " ")
    ++ "type "
    ++ typeName
    ++ typeParamsString
    ++ " = "
    ++ (typ |> typToString(~language))
    ++ ";"
    ++ commentString

  | Typescript =>
    if (opaque) {
      /* Represent an opaque type as an absract class with a field called 'opaque'.
         Any type parameters must occur in the type of opaque, so that different
         instantiations are considered different types. */
      let typeOfOpaqueField =
        typeParams == [] ?
          "any" :
          typeParams
          |> List.map(typToString(~language))
          |> String.concat(" | ");
      "// tslint:disable-next-line:max-classes-per-file \n"
      ++ "export abstract class "
      ++ typeName
      ++ typeParamsString
      ++ " { protected opaque: "
      ++ typeOfOpaqueField
      ++ " }; /* simulate opaque types */"
      ++ commentString;
    } else {
      "// tslint:disable-next-line:interface-over-type-literal\n"
      ++ "export type "
      ++ typeName
      ++ typeParamsString
      ++ " = "
      ++ (typ |> typToString(~language))
      ++ ";"
      ++ commentString;
    }
  | Untyped => ""
  };
};

let emitExportVariantType = (~language, ~name, ~typeParams, ~leafTypes) =>
  switch (language) {
  | Flow
  | Typescript =>
    "export type "
    ++ name
    ++ genericsString(List.map(typToString(~language), typeParams))
    ++ " =\n  | "
    ++ String.concat(
         "\n  | ",
         List.map(typToString(~language), leafTypes),
       )
    ++ ";"
  | Untyped => ""
  };

let emitRequire = (~language, moduleName, importPath) =>
  commentBeforeRequire(~language)
  ++ "const "
  ++ ModuleName.toString(moduleName)
  ++ " = require(\""
  ++ (importPath |> ImportPath.toString)
  ++ "\");";

let requireReact = (~language) =>
  switch (language) {
  | Flow => emitRequire(~language, ModuleName.react, ImportPath.react)
  | Typescript => "import * as React from \"react\";"
  | Untyped => ""
  };

let reactComponentType = (~language, ~propsTypeName) =>
  Ident(
    language == Flow ? "React$ComponentType" : "React.ComponentClass",
    [Ident(propsTypeName, [])],
  );

let fileHeader = (~language) =>
  switch (language) {
  | Flow => "/* @flow strict */\n"
  | Typescript => "/* Typescript file generated by genFlow. */\n"
  | Untyped => "/* Untyped file generated by genFlow. */\n"
  };

let componentExportName = (~language, ~moduleName) =>
  language == Flow ? "component" : ModuleName.toString(moduleName);

let outputFileSuffix = (~language) =>
  switch (language) {
  | Flow
  | Untyped => ".re.js"
  | Typescript => ".tsx"
  };

let generatedModuleExtension = (~language) => language == Flow ? ".re" : "";

let emitImportTypeAs = (~language, ~typeName, ~asTypeName, ~importPath) =>
  switch (language) {
  | Flow
  | Typescript =>
    (language == Flow ? "" : "\n")
    ++ "import "
    ++ (language == Flow ? "type " : "")
    ++ "{"
    ++ typeName
    ++ (
      switch (asTypeName) {
      | Some(asT) => " as " ++ asT
      | None => ""
      }
    )
    ++ "} from '"
    ++ (importPath |> ImportPath.toString)
    ++ "';"
  | Untyped => ""
  };

let blockTagValue = (~language, i) =>
  string_of_int(i) ++ (language == Typescript ? " as any" : "");

let shimExtension = (~language) =>
  switch (language) {
  | Flow => ".shim.js"
  | Typescript => ".shim.ts"
  | Untyped => ".shim.not.used"
  };